Tomcat中对severLocation的配置（对于配置成灰色的处理）

说明：Eclipse默认使用工作空间下项目数据，不会自动发布到Tomcat的webapps下
 
双击Server，确保Server下没有项目，否则修改不了，还不能修改就clean一下
 
 

弹出服务器配置信息窗口

 
选择Use Tomcat installation，Server path会跟着改变，将Deploy path修改为webapps，默认是wtpwebapps，ctrl+s保存

部署项目到Server，启动，发现项目发布到Tomcat下的webapps了。
 
 
解决了该问题：先将该server关闭（stop），然后在model模式下把关联项目remove，注意一定要保存才行，然后在overView配置。



文件复制是分离的，
如一个C.JS文件分别被A.HTML、B.HTML引入了，在A.HTML中对它的修改，如全局变量，在B中是看不到变化的。

要将ECLIPSE的编码设置为UTF-8: Window-Preferences-General-Workspace在右则设置为UTF-8

如果项目的是乱码，在WINDOWS目录下找到那个文件，打开，将其复制到ECLIPSE中，它会自动转码的。


如何在 cmd 命令行中查看、修改、删除与添加环境变量

1. 关于Java环境变量的配置

 http://www.2cto.com/kf/201203/122872.html

2.环境变量的定义

环境变量是一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如path，当要求系统运行一

个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用

户通过设置环境变量，来更好的运行进程。

 

3.查看，修改

 

首先明确一点，所有的在cmd命令行下对环境变量的修改只对当前窗口有效，不是永久性的修改。也就是说当关闭此cmd命

令行窗口后，将不再起作用。永久性修改环境变量的方法有两种：一种是直接修改注册表，另一种是通过我的电脑-〉属

性-〉高级，来设置系统的环境变量

 

显示、设置或删除 cmd.exe 环境变量。

SET [variable=[string]]

variable 指定环境变量名。
string 指定要指派给变量的一系列字符串。

要显示当前环境变量，键入不带参数的 SET。

 

 

1、查看当前所有可用的环境变量：输入 set 即可查看。

2、查看某个环境变量：输入 “set 变量名”即可，比如想查看path变量的值，即输入 set path

 

4.Windows 和 linux 区别

一、查看所有环境变量的名称和值：
Linux下：export
Windows下：set
二、根据名称查该环境变量的值：
Linux下：echo $环境变量名
比如：echo $ORACLE_HOME
Windows下：set 环境变量名


eclipse中使用maven插件的时候，运行run as maven build的时候报错
-Dmaven.multiModuleProjectDirectory system propery is not set. Check $MAVEN_HOME environment variable and 

mvn script match.
 
直接的解决方法：使用低版本的maven
 
可以设一个环境变量M2_HOME指向你的maven安装目录
MAVEN_HOME=D:\Apps\apache-maven-3.3.1
然后在Window->Preference->Java->Installed JREs->Edit
在Default VM arguments中设置
-Dmaven.multiModuleProjectDirectory=$MAVEN_HOME



数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。reverse()方法会对反转数组项的顺序。请看下面

的例子：

var values = [1, 2, 3, 4, 5];
values.reverse();
alert(values);  //5,4,3,2,1


当你使用DWZ框架的时候，动态设置select的值，可能会没反应，此时，你要用如下的方法设置：
var language = msg.data.language;
$("select[name='language'] option", "#dt_form").each(function() {
	if (this.value == language) {
		$(this).attr("selected", "selected");
		
		// 要加上这两行，因为DWZ会帮我会生成这些用于显示
		$("a[name='language']", "#dt_form").val(language);
		$("a[name='language']", "#dt_form").text(this.text);
	}
});


你在HTML中输入的有换行、段落等的文本存到DB中，再取回并显示到网页中的时候，可能这些换行、分段等
标识可能已经没有了， 其实你只要在添加数据的时候添加一个pre标签就可以了
<pre> 正文 就可以保留换行符号等 </pre>


解决cookie跨域问题，在cookiey设置的时候加上PATH，如：document.cookie = cookieString + "; path=/";


公元纪年换算成干支纪年
算法：
1. 天干算法：用公元纪年数减3，除以10（不管商数）所得余数，就是天干所对应的位数；
2. 地支算法：用公元纪年数减3，除以12（不管商数）所得余数，就是地支所对应的位数；
天干：甲、乙、丙、丁、戊、己、庚、辛、壬、癸
地支：子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥

例1. 我们以2010年为例；
天干算法： 2010-3=2007， 2007/10=200余7， 7对应天干第7位是庚，即天干为庚；
地支算法： 2010-3=2007， 2007/12=167余3， 3对应地支第3位是寅，即地支为寅；
综上公元2010是用天干地支纪年为庚寅年。为使各位信任此算法，我再举一例来说明：

例2. 我们再以1987年为例；
天干算法： 1987-3=1984， 1984/10=198余4， 4对应天干第4位是丁，即天干为丁；
地支算法： 1987-3=1984， 1984/12=165余4， 4对应地支第4位是卯，即地支为卯；
综上公元1987是用天干地支纪年为丁卯年。



将查询结果下载，实现如下：
@RequestMapping(value = "hostDownStatSumDown")
	public void hostDownStatSumDown(HttpServletResponse response,
			String startTime, String endTime) throws Exception {
		byte[] buf = baseService.getHostDownStatsSumDown(startTime, endTime);
		ByteArrayInputStream bais = new ByteArrayInputStream(buf);
		int contentLength = bais.available();
		OutputStream os = null;

		try {
			String filename = "爬取数据汇总-" + DateUtil.getDateToString(new Date())
					+ ".csv";
			response.setContentType("application/force-download");
			response.addHeader("Content-Disposition", "attachment;filename="
					+ URLEncoder.encode(filename, "UTF-8"));
			response.setContentLength(contentLength);
			os = response.getOutputStream();

			byte[] b = new byte[1024];
			int len = 0;
			while ((len = bais.read(b)) != -1) {
				os.write(b, 0, len);
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (null != bais) {
				try {
					bais.close();
					bais = null;
				} catch (Exception e2) {
					e2.printStackTrace();
				}
			}
			if (null != os) {
				try {
					os.close();
				} catch (Exception e2) {
					e2.printStackTrace();
				}
			}
		}
	}
	
	
	@Override
	public byte[] getHostDownStatsSumDown(String startTime, String endTime) {
		byte[] bytes = null;
		Map<String, Integer> res = baseDao.getHostDownStatsSum(startTime,
				endTime);

		StringBuilder sb = new StringBuilder("下载数,处理数,修改数,新增数");
		sb.append(System.getProperty("line.separator")); // 注意，一定要用这种方式产生换行符
		sb.append(res.get("downloadNum") + ",");
		sb.append(res.get("handleNum") + ",");
		sb.append(res.get("modifyNum") + ",");
		sb.append(res.get("newNum"));

		try {
			bytes = sb.toString().getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return bytes;
	}