结点的层次从根开始定义起,根为第一层,根的孩子为第二层,依次累计.
树中结点的最大层次称为树的深度或高度.

从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
例如：输入二元树：
                                           10
                                          /    \
                                        6       14
                                      /         /   \
                                    4        12     16
输出该树的深度3。


宽度:节点的叶子数
深度:节点的层数

算法上有所谓的"宽度优先算法"和"深度优先算法"

二叉树的宽度定义为具有最多结点数的层中包含的结点数。

比如上图中，
第1层有1个节点， 
第2层有2个节点， 
第3层有3个节点， 
可知，第3层的结点数最多
所以这棵二叉树的宽度就是3


相关术语
	树的结点：包含一个数据元素及若干指向子树的分支；
	孩子结点：结点的子树的根称为该结点的孩子；
	双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；
	兄弟结点：同一双亲的孩子结点； 
	堂兄结点：同一层上结点；
	祖先结点: 从根到该结点的所经分支上的所有结点
	子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙
	结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；
	树的深度：树中最大的结点层
	结点的度：结点子树的个数
	树的度： 树中最大的结点度。
	叶子结点：也叫终端结点，是度为 0 的结点；
	分枝结点：度不为0的结点；
	有序树：子树有序的树，如：家族树；
	无序树：不考虑子树的顺序；

遍历顺序
	遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。
	由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。
	设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。

	只要是搞计算机的，对数据结构中二叉树遍历都不陌生，但是如果用到的机会不多那么就会慢慢淡忘，温故而之新才是最好的学习方式，现在就重新温习一下这方面的知识。

首先我想先改变这几个遍历的名字（前根序遍历，中根序遍历，后根序遍历）；前中后本来就是相对于根结点来说的，少一个字会产生很多不必要的误解。
			A
		B		C
	D		E F		G
H

1. 前根序遍历：先遍历根结点，然后遍历左子树，最后遍历右子树。
ABDHECFG

2.中根序遍历：先遍历左子树，然后遍历根结点，最后遍历右子树。
HDBEAFCG

3.后根序遍历：先遍历左子树，然后遍历右子树，最后遍历根节点。
HDEBFGCA

已知一棵二叉树的前根序序列和中根序序列，构造该二叉树的过程如下：
1. 根据前根序序列的第一个元素建立根结点；
2. 在中根序序列中找到该元素，确定根结点的左右子树的中根序序列；
3. 在前根序序列中确定左右子树的前根序序列；
4. 由左子树的前根序序列和中根序序列建立左子树；
5. 由右子树的前根序序列和中根序序列建立右子树。

已知一棵二叉树的后根序序列和中根序序列，构造该二叉树的过程如下：
1. 根据后根序序列的最后一个元素建立根结点；
2. 在中根序序列中找到该元素，确定根结点的左右子树的中根序序列；
3. 在后根序序列中确定左右子树的后根序序列；
4. 由左子树的后根序序列和中根序序列建立左子树；
5. 由右子树的后根序序列和中根序序列建立右子树。


Double-Array Trie
参阅这个：
http://blog.csdn.net/zzran/article/details/8462002
http://www.hankcs.com/program/java/%E5%8F%8C%E6%95%B0%E7%BB%84trie%E6%A0%91doublearraytriejava%E5%AE%9E%E7%8E%B0.html
http://www.cnblogs.com/zhangchaoyang/articles/4508266.html
https://linux.thai.net/~thep/datrie/datrie.html
